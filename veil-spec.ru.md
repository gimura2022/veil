# Спецификация veil'a

## Синтаксис
В топлевеле должны лежать определения функций которые заканчиваются на ";".
Так же возможно создавать комментарии с помощю "//".

## Типы
По умолчанию в языке есть следующие типы:
- void
- type
- fn
- mod

### Тип void
Необходим для того что бы не возвращять ничего из функции,
так же его возвращяют некоторые условные конструкции.
Создание переменных с типом void невозможно тк он не имеет
размера и реального представления в памяти.

Пример:
```
impure main std.array(str) -> void = { ... };
```

### Тип type
Тип type является типом типов, у него могут быть ограничения
так как он часто используется для темплейтирования, что бы
добавить ограничение необходимо поставить круглые скобки после ключегово слова
и вписать туда функции (лямбды или имена глобальных функций) которые имеют
следующую сигнатуру: `constexpr T::type -> bool`. Если в переменную с таким типом
попадёт тип без ограничений или тип типов в котором уже есть некоторые нужные ограничения
но не все компилятор обязан вызвать нужные функции используя как аргумент передаваемый тип
и если функция вернёт false компилятор будет обязан выкинуть ошибку так как данный тип не 
подходит по ограничениям.

Примеры:
```
constexpr some_template_funtion T::type(@number) -> ... = ...;

some_template_funtion(i32); // ok
some_template_funtion(str); // compilation error: type doesn't match requirements
```

#### Объявление своих ограничений
Что бы объявить своё ограничение есть 2 пути:
1. Совместить несколько других ограничений (`constexpr num_and_ptr T::type -> bool = @number(T) || @ptrable(T);`)
2. Использовать ключевое слово check.

Ключевое слово check позволяет проверить валидность кода и если в нём не будет ошибок оно вернёт true,
в противном случаи false. Ключевое слово check имеет такой синтаксис:
```
check (<argument_name::argument_type...>) { <expression(s) to check> }
```

Примеры:
```
constexpr custom_limitation T::type -> bool = check (x::T) { x + x };
```

### Тип fn
Данный тип нужен для того что бы оперировать функциями. Что бы его
использовать нужен вот такой синтаксис:
```
fn(<argument_name::argument_type...> -> return_type)
```
Тип будет работать по разному во время компиляции и во время выполнения:
- Во время компиляции тип должен значить сигнатуру функции а так же её представление в ast.
- Во время выполнения тип должен значить ссылку на скомпилированную функцию, при этом тип нельзя вернуть из функции, только передавать в аргумент.

### Тип mod
Данный тип представляет собой модули, он может быть использован только
во время компиляции. Встроенная функция @include возвращяет данный тип для представления
модулей. Что бы обратится к какому либо члену модуля необходимо поставить точку между выражением
возвращяюшим модуль и именем члена.

Пример:
```
constexpr std -> mod = @import("std");
```

## Функции
Функции могут быть объявлены 2 возможными путями, или через список объявляемых функций,
или через лямбда выражения. Далее что бы определить функцию можно использовать 2 разных пути:
- Написать выражение которое должно быть выполнено при выполнении функции
- Написать имя функции/лямбду сигнатура которых (типы аргументов и тип возврата) сходна с сигнатурой функции/лямбды

### Синтаксис функции
Программа по сути состоит из объявлений функций, де факто всё есть функция.
Каждое полное объявление функции должно содержать её имя, тип результата выполнения
и заканчиватся на ";". Перед началом функции могут стоять так называемые флаги
которые нужны для того что бы изменять поведение определения.

Это всё имеет вот такой синтаксис:
```
<flags...> function_name <argument_name::argument_type...> -> return_type = function_definition;
```

Примеры:
```
impure main args::std.array(str) -> void = ...;
```

### Вызов функции
Вызов функции производится по средством постановки круглых скобочек
после имени функции или лямбды, если функция не имеет аргументов то скобочки можно не ставить.

Пример:
```
square x::i32 -> i32 = x * x;
square2 -> i32 = square(2);

square(10); // 100
square2; // 4
```

### Синтаксис лямбды
Второй метод объявления функций это лямбда выражения, лямбда выражения по факту те же функции,
но они могут быть объявлены анонимно без имени. Синтаксис объявления лямбды:
```
(<flags...> <argument_name::argument_type...> -> return_type | <lambda_definition>)
```

Примеры:
```
square_with_lambda x::i32 -> i32 = (x::i32 -> i32 | x * x);
```

### Флаги функций
Вот все флаги доступные при объявлении функций:
| Имя | Описание |
| --- | --- |
| constexpr | Функция должна быть выполнена на этапе компиляции и её результат должен быть подставлен в программу, в целом можно подставлять результат на этапе абстрактного синтаксического дерева |
| export | Экспортирование функции из модуля (другими словами сделать функцию публичной) |
| impure | Разрешает использовать нечистые функции внутри функции а так же делает функцию нечистой |
| nomangle | Делает имя функции в сгенерированном бинарнике таким же как и в коде но в замен запрещяет создавать перегрузки для данной функции |
| extern | Даёт возможность импортировать функцию из внешних библиотек, при включённом флаге реализацию указывать не нужно |
| pure | Используется с флагом extern что бы компилятор пометил экспортированную функцию как чистую, по умолчанию компилятор должен требовать impure флаг |
| operator | Делает функцию бинарным оператором, имя становится именем оператора, функция должна иметь строго 2 аргумента |
| loperator | Делает функцию унарным оператором слева, функция должна иметь строго 1 аргумент |
| roperator | Делает функцию унарным оператором справа, функция должна иметь строго 1 аргумент |

### Перегрузка функций
Можно определить 2 функции с одним именем и флагами при этом сигнатуры которых будут отличатся,
при вызове функции компилятор попытается найти функцию сигнатура которой будет у какой либо из перегрузок
и вызовет найденую функцию. Перегрузка функций заставляет компилятор менять имена функций добавляя в них дополнительные
мета данные, что бы избежать изменения имени функции нужно использовать флаг nomangle но при этом
перегрузка будет недоступна.

Пример:
```
f x::i32 -> bool = if (x == 0) false else true;
f x::bool -> bool = x;

f(10); // true
f(0); // false
f(false); // false
```

### Паттерн матчинг
В можно определить функцию не задавая имя аргумента а задав сразу его значение,
тогда это определение функции будет вызвано если значение указанное в аргументе
совпадает с аргументом. Проверка происходт не по порядку, то есть если сначала
указать аргумент с именем а потом со значением первым выполнится проверка аргумента по значению,
но порядок проверки аргументов со значением такой же как и в коде.

Пример:
```
or false::bool false::bool -> bool = false;
or true::bool false::bool -> bool = true;
or false::bool true::bool -> bool = true;
or true::bool true::bool -> bool = true;
```

## Встроенные функции
Функции которые нужны для каких то базовых вещей, например функция сложения,
конечно можно определить оператор прямо внутри компилятора но мне кажется это не самая лучшая идея.
Все встроенные функции начинаются с "@" и работают как самые обыкновенные функции которые просто определяются внутри компилятора.

### @number
Ограничение типов для чисел, в него входят @u, @i, @f, @numlit, @floatlit

Сигнатура: `constexpr T::type -> bool`

### @numlit
Тип целых числовых литералов.

Сигнатура: `constexpr -> type(@number)`

### @floatlit
Тип числовых литералов с плавающей точкой.

Сигнатура: `constexpr -> type(@number)`

### @strlit
Тип строковых литералов.

Сигнатура: `constexpr -> type`

### @u
Тип бесзнаковых чисел, в аргументе необходимо указать битность.

Сигнатура: `constexpr bits::@numlit -> type(@number)`

### @i
Тип знаковых чисел, в аргументе необходимо указать битность.

Сигнатура: `constexpr bits::@numlit -> type(@number)`

### @f
Тип чисел c плавающей точкой, в аргументе необходимо указать битность.

Сигнатура: `constexpr bits::@numlit -> type(@number)`

### @add
Темплейт который возвращяет функцию для сложения 2 чисел.

Сигнатура: `constexpr T::type(@number) -> fn(a::T b::T -> T)`

### @sub
Темплейт который возвращяет функцию для вычитания 2 чисел.

Сигнатура: `constexpr T::type(@number) -> fn(a::T b::T -> T)`

### @mul
Темплейт который возвращяет функцию для умножения 2 чисел.

Сигнатура: `constexpr T::type(@number) -> fn(a::T b::T -> T)`

### @div
Темплейт который возвращяет функцию для деления 2 чисел.

Сигнатура: `constexpr T::type(@number) -> fn(a::T b::T -> T)`

### @ptr
Темплейт тип ссылки.

Сигнатура: `constexpr T::type -> type(@ptrable)`

### @ptrable
Ограничение которое проверяет является ли тип ссылкой.

Сигнатура: `constexpr T::type -> bool`

### @val
Темплейт функция для получения значения из ссылки.

Сигнатура: `constexpr T::type -> fn(x::@ptr(T) -> T)`

### @addr
Темплейт функция для получения ссылки из чего либо.

Сигнатура: `constexpr T::type -> fn(T -> @ptr(T))`

### @equalable
Ограничение которое проверяет можно ли сравнивать тип или нет.

Сигнатура: `constexpr T::type -> bool`

### @lessable
Ограничение которое проверяет можно ли проверять то что один эсемпляр типа меньше другово или нет.

Сигнатура: `constexpr T::type -> bool`

### @greatable
Ограничение которое проверяет можно ли проверять то что один эсемпляр типа больше другово или нет.

Сигнатура: `constexpr T::type -> bool`

### @equals
Темплейт функция которая сравнивает 2 значения.

Сигнатура: `constexpr T::type(@equalable) -> fn(a::T b::T -> bool)`

### @less
Темплейт функция которая проверяет что одно значение меньше другово.

Сигнатура: `constexpr T::type(@lessable) -> fn(a::T b::T -> bool)`

### @greater
Темплейт функция которая проверяет что одно значение больше другово.

Сигнатура: `constexpr T::type(@greatable) -> fn(a::T b::T -> bool)`

### @not
Функция логического отридцания (!x).

Сигнатура: `x::bool -> bool`

### @and
Функция логического и (a && b).

Сигнатура: `a::bool b::bool -> bool`

### @or
Функция логического или (a && b).

Сигнатура: `a::bool b::bool -> bool`

### @import
Импортирует модуль с указанным именем.

Сигнатура: `constexpr s::@strlit -> mod`

## Структуры
Структуры позволяют группировать данные в одном типе или создавать новый тип со старыми.

### Синтаксис
Что бы объявить тип структуры необходимо использовать синтаксис:
```
struct {
    <field_name::field_type...>
}
```

### Темплейтирование структур
Структуры можно темплейтировать как и другие типы:
```
constexpr some_struct T::type -> type = struct {
    some_field::T
};
```

### Конструкторы
Что бы создать эксемпляр структуры надо поставить круглые скобки после типа
и вписать туда значения всех полей структуры по порядку:
```
constexpr a -> type = struct { x::i32 };

instance -> a = a(10);
```

### Обращение к полям
Что бы обратится к полю структуры нужно использовать ".":
```
constexpr a -> type = struct { x::i32 };

instance -> a = a(10);
x_in_instance -> i32 = instance.x;
```

## Модули
Модули позволяют подключать код из других файлов в текущий.
Важнейшие концепции модулей это ключевое слово export,
тип mod, а так же встроенная функция @import. Стоит отметить
что модули работают только во время компиляции так как ключевое слово
@import а так же тип mod доступны только тогда.

Пример:
*файл main.ve*
```
constexpr std -> mod = @import("std");
constexpr lib -> mod = @import("lib");

impure main args::std.array(str) -> void = std.println("10 ** 2 = {}", lib.square(10));
```
*файл lib.ve*
```
export square x::i32 -> i32 = x * x;
```

### Ключевое слово include
Иногда надо подключать некоторые модули прямо к текущему модулю
без использования промежуточных переменных, в таком случаи можно
использовать ключевое слово include, оно имеет следующий синтаксис:
```
include <some_module>;
```

Пример:
*файл main.ve*
```
constexpr std -> mod = @import("std");

include @import("lib");

impure main args::std.array(str) -> void = std.println("10 ** 2 = {}", square(10));
```
