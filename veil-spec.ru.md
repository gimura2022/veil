# Спецификация veil'a

## Синтаксис
В топлевеле должны лежать определения функций которые заканчиваются на ";".
Так же возможно создавать комментарии с помощю "//".

## Типы
По умолчанию в языке есть следующие типы:
| Имя | Описание |
| --- | --- |
| void | Виртуальный тип (безразмерный) необходимый в нечистых функциях для того что бы не возвращять результат. |
| type(<requirements...>) | Тип типов, может использоватся только в контексте выражений времени компиляции, requirements это функции времени компиляции которые принимают тип без ограничений и возвращяют true если тип подходит под ограничение и false если не подходит, если у типа нет ограничений валиден любой тип. |
| fn(<flags...> <argument_name::argument_type...> -> return_type) | Tип обозначающий функцию (лямбду или просто функцию), не может быть возвращён из функции если функция не является функцией времени компиляции, в случаи если используется как аргумент функции должен представлять собой ссылку на функцию, если же он возвращяется из функции времени компиляции он должен представлять из себя сигнатуру функции и её код в виде AST для возможности темплейтирования функций |

## Функции
Функции могут быть объявлены 2 возможными путями, или через список объявляемых функций,
или через лямбда выражения. Далее что бы определить функцию можно использовать 2 разных пути:
- Написать выражение которое должно быть выполнено при выполнении функции
- Написать имя функции/лямбду сигнатура которых (типы аргументов и тип возврата) сходна с сигнатурой функции/лямбды

### Синтаксис функции
Программа по сути состоит из объявлений функций, де факто всё есть функция.
Каждое полное объявление функции должно содержать её имя, тип результата выполнения
и заканчиватся на ";". Перед началом функции могут стоять так называемые флаги
которые нужны для того что бы изменять поведение определения.

Это всё имеет вот такой синтаксис:
```
<flags...> function_name <argument_name::argument_type...> -> return_type = function_definition;
```

Примеры:
```
impure main args::std.array(std.string) -> void = ...;
```

### Синтаксис лямбды
Второй метод объявления функций это лямбда выражения, лямбда выражения по факту те же функции,
но они могут быть объявлены анонимно без имени. Синтаксис объявления лямбды:
```
(<flags...> <argument_name::argument_type...> -> return_type | <lambda_definition>)
```

Примеры:
square_with_lambda x::int -> int = (x::int -> int | x * x);

### Флаги функций
Вот все флаги доступные при объявлении функций:
| Имя | Описание |
| --- | --- |
| constexpr | Функция должна быть выполнена на этапе компиляции и её результат должен быть подставлен в программу, в целом можно подставлять результат на этапе абстрактного синтаксического дерева |
| export | Экспортирование функции из модуля (другими словами сделать функцию публичной) |
| impure | Разрешает использовать нечистые функции внутри функции а так же делает функцию нечистой |
| nomangle | Делает имя функции в сгенерированном бинарнике таким же как и в коде но в замен запрещяет создавать перегрузки для данной функции |
| extern | Даёт возможность импортировать функцию из внешних библиотек, при включённом флаге реализацию указывать не нужно |
| pure | Используется с флагом extern что бы компилятор пометил экспортированную функцию как чистую, по умолчанию компилятор должен требовать impure флаг |
| operator | Делает функцию бинарным оператором, имя становится именем оператора, функция должна иметь строго 2 аргумента |
| loperator | Делает функцию унарным оператором слева, функция должна иметь строго 1 аргумент |
| roperator | Делает функцию унарным оператором справа, функция должна иметь строго 1 аргумент |

### Перегрузка функций
Можно определить 2 функции с одним именем и флагами при этом сигнатуры которых будут отличатся,
при вызове функции компилятор попытается найти функцию сигнатура которой будет у какой либо из перегрузок
и вызовет найденую функцию. Перегрузка функций заставляет компилятор менять имена функций добавляя в них дополнительные
мета данные, что бы избежать изменения имени функции нужно использовать флаг nomangle но при этом
перегрузка будет недоступна.

Пример:
```
f x::int -> bool = if (x == 0) false else true;
f x::bool -> bool = x;

f(10); // true
f(0); // false
f(false); // false
```

### Паттерн матчинг
В можно определить функцию не задавая имя аргумента а задав сразу его значение,
тогда это определение функции будет вызвано если значение указанное в аргументе
совпадает с аргументом. Проверка происходт не по порядку, то есть если сначала
указать аргумент с именем а потом со значением первым выполнится проверка аргумента по значению,
но порядок проверки аргументов со значением такой же как и в коде.

Пример:
```
or false::bool false::bool = false;
or true::bool false::bool = true;
or false::bool true::bool = true;
or true::bool true::bool = true;
```

## Встроенные функции
Функции которые нужны для каких то базовых вещей, например функция сложения,
конечно можно определить оператор прямо внутри компилятора но мне кажется это не самая лучшая идея.
Все встроенные функции начинаются с "@" и работают как самые обыкновенные функции которые просто определяются внутри компилятора.
Вот список таких функций:
| Имя | Сигнатура | Описание |
| --- | --- | --- |
| @numlit | constexpr -> type(@number) | Тип знакогово числогово литерала, не стоит использовать в обычных программах так как его размер может менятся |
| @floatlit | constexpr -> type(@number) | Тип литерела с плавающей точкой, так же может менять свой размер в зависимости от архитектуры и компилятора |
| @u | constexpr bits::@numlit -> type(@number) | Создаёт тип беззнакогово числа с указанной битностью, битность может быть больше указанной но не меньше |
| @i | constexpr bits::@numlit -> type(@number) | Создаёт тип знакогово числа с указанной битностью, битность может быть больше указанной но не меньше |
| @f | constexpr bits::@numlit -> type(@number) | Создаёт тип числа с плавающей точкой с указанной битностью, битность может быть больше указанной но не меньше |
| @number | constexpr T::type -> bool | Ограничение для чисел, в числа входят все типы сгенерированные @u, @i и @f а так же @numlit и @floatlit |
| @add | constexpr T::type(@number) -> fn(a::T b::T -> T) | a + b |
| @sub | constexpr T::type(@number) -> fn(a::T b::T -> T) | a - b |
| @mul | constexpr T::type(@number) -> fn(a::T b::T -> T) | a * b |
| @div | constexpr T::type(@number) -> fn(a::T b::T -> T) | a / b |
| @ptrable | constexpr T::type -> bool | Ограничение для типов ссылок |
| @ptr | constexpr T::type -> type | Создаёт тип ссылки на основе переданного типа |
| @val | constexpr T::type -> fn(x::@ptr(T) -> T) | Темплейт функция для разыменовывание ссылки |
| @addr | constexpr T::type -> fn(x::T -> @ptr(T)) | Темплейт функция для получения ссылки из объекта |
| @comparable | constexpr T::type -> bool | Ограничение для типов которые можно сравнивать, по факту это @number и @ptrable |
| @equals | constexpr T::type(@comparable) -> fn(a::T b::T -> @u(1)) | a == b, @u(1) по факту означает bool |
| @less | constexpr T::type(@comparable) -> fn(a::T b::T -> @u(1)) | a < b |
| @greater | constexpr T::type(@comparable) -> fn(a::T b::T -> @u(1)) | a > b |
| @not | x::@u(1) -> @u(1) | !x |
| @and | a::@u(1) b::@u(1) -> @u(1) | a && b |
| @or | a::@u(1) b::@u(1) -> @u(1) | a || b |

## Структуры
