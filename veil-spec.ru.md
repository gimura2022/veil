# Спецификация языка
В этом разделе говорится непосредственно о языке его синтаксисе
основам и тому без чего он не заработает.

## Синтаксис
В топлевеле должны лежать определения функций которые заканчиваются на ";".
Так же возможно создавать комментарии с помощю "//".

## Типы
По умолчанию в языке есть следующие типы:
- void
- type
- fn
- mod

### Тип void
Необходим для того что бы не возвращять ничего из функции,
так же его возвращяют некоторые условные конструкции.
Создание переменных с типом void невозможно тк он не имеет
размера и реального представления в памяти.

Пример:
```
impure main std.array(str) -> void = { ... };
```

### Тип type
Тип type является типом типов, у него могут быть ограничения
так как он часто используется для темплейтирования, что бы
добавить ограничение необходимо поставить круглые скобки после ключегово слова
и вписать туда функции (лямбды или имена глобальных функций) которые имеют
следующую сигнатуру: `constexpr T::type -> bool`. Если в переменную с таким типом
попадёт тип без ограничений или тип типов в котором уже есть некоторые нужные ограничения
но не все компилятор обязан вызвать нужные функции используя как аргумент передаваемый тип
и если функция вернёт false компилятор будет обязан выкинуть ошибку так как данный тип не 
подходит по ограничениям.

Примеры:
```
constexpr some_template_funtion T::type(@number) -> ... = ...;

some_template_funtion(i32); // ok
some_template_funtion(str); // compilation error: type doesn't match requirements
```

#### Объявление своих ограничений
Что бы объявить своё ограничение есть 2 пути:
1. Совместить несколько других ограничений (`constexpr num_and_ptr T::type -> bool = @number(T) || @ptrable(T);`)
2. Использовать ключевое слово check.

Ключевое слово check позволяет проверить валидность кода и если в нём не будет ошибок оно вернёт true,
в противном случаи false. Ключевое слово check имеет такой синтаксис:
```
check (<argument_name::argument_type...>) {
    { <expr> } -> (<requirements to return type>),
}
```

Примеры:
```
constexpr custom_limitation T::type -> bool = check (x::T) {
    { x + x } -> (same_as(T)),
};
```

### Тип fn
Данный тип нужен для того что бы оперировать функциями. Что бы его
использовать нужен вот такой синтаксис:
```
fn(<argument_name::argument_type...> -> return_type)
```
Тип будет работать по разному во время компиляции и во время выполнения:
- Во время компиляции тип должен значить сигнатуру функции а так же её представление в ast.
- Во время выполнения тип должен значить ссылку на скомпилированную функцию, при этом тип нельзя вернуть из функции, только передавать в аргумент.

### Тип mod
Данный тип представляет собой модули, он может быть использован только
во время компиляции. Встроенная функция @include возвращяет данный тип для представления
модулей. Что бы обратится к какому либо члену модуля необходимо поставить точку между выражением
возвращяюшим модуль и именем члена.

Пример:
```
constexpr std -> mod = @import("std");
```

## Функции
Функции могут быть объявлены 2 возможными путями, или через список объявляемых функций,
или через лямбда выражения. Далее что бы определить функцию можно использовать 2 разных пути:
- Написать выражение которое должно быть выполнено при выполнении функции
- Написать имя функции/лямбду сигнатура которых (типы аргументов и тип возврата) сходна с сигнатурой функции/лямбды

### Синтаксис функции
Программа по сути состоит из объявлений функций, де факто всё есть функция.
Каждое полное объявление функции должно содержать её имя, тип результата выполнения
и заканчиватся на ";". Перед началом функции могут стоять так называемые флаги
которые нужны для того что бы изменять поведение определения.

Это всё имеет вот такой синтаксис:
```
<flags...> function_name <argument_name::argument_type...> -> return_type = function_definition;
```

Примеры:
```
impure main args::std.array(str) -> void = ...;
```

### Вызов функции
Вызов функции производится по средством постановки круглых скобочек
после имени функции или лямбды, если функция не имеет аргументов то скобочки можно не ставить.

Пример:
```
mul a::i32 b::i32 -> i32 = a * b;
mul2x2 -> i32 = mul(2, 2);

mul(10, 10) // 100
mul2x2 // 4
```

### Синтаксис лямбды
Второй метод объявления функций это лямбда выражения, лямбда выражения по факту те же функции,
но они могут быть объявлены анонимно без имени. Синтаксис объявления лямбды:
```
(<flags...> <argument_name::argument_type...> -> return_type | <lambda_definition>)
```

Примеры:
```
square_with_lambda x::i32 -> i32 = (x::i32 -> i32 | x * x);
```

### Флаги функций
Вот все флаги доступные при объявлении функций:
| Имя | Описание |
| --- | --- |
| constexpr | Функция должна быть выполнена на этапе компиляции и её результат должен быть подставлен в программу, в целом можно подставлять результат на этапе абстрактного синтаксического дерева |
| export | Экспортирование функции из модуля (другими словами сделать функцию публичной) |
| impure | Разрешает использовать нечистые функции внутри функции а так же делает функцию нечистой |
| nomangle | Делает имя функции в сгенерированном бинарнике таким же как и в коде но в замен запрещяет создавать перегрузки для данной функции |
| extern | Даёт возможность импортировать функцию из внешних библиотек, при включённом флаге реализацию указывать не нужно |
| pure | Используется с флагом extern что бы компилятор пометил экспортированную функцию как чистую, по умолчанию компилятор должен требовать impure флаг |
| operator | Делает функцию бинарным оператором, имя становится именем оператора, функция должна иметь строго 2 аргумента |
| loperator | Делает функцию унарным оператором слева, функция должна иметь строго 1 аргумент |
| roperator | Делает функцию унарным оператором справа, функция должна иметь строго 1 аргумент |

### Перегрузка функций
Можно определить 2 функции с одним именем и флагами при этом сигнатуры которых будут отличатся,
при вызове функции компилятор попытается найти функцию сигнатура которой будет у какой либо из перегрузок
и вызовет найденую функцию. Перегрузка функций заставляет компилятор менять имена функций добавляя в них дополнительные
мета данные, что бы избежать изменения имени функции нужно использовать флаг nomangle но при этом
перегрузка будет недоступна.

Пример:
```
f x::i32 -> bool = if (x == 0) false else true;
f x::bool -> bool = x;

f(10); // true
f(0); // false
f(false); // false
```

### Паттерн матчинг
В можно определить функцию не задавая имя аргумента а задав сразу его значение,
тогда это определение функции будет вызвано если значение указанное в аргументе
совпадает с аргументом. Проверка происходт не по порядку, то есть если сначала
указать аргумент с именем а потом со значением первым выполнится проверка аргумента по значению,
но порядок проверки аргументов со значением такой же как и в коде.

Пример:
```
or false::bool false::bool -> bool = false;
or true::bool false::bool -> bool = true;
or false::bool true::bool -> bool = true;
or true::bool true::bool -> bool = true;
```

## Встроенные функции
Функции которые нужны для каких то базовых вещей, например функция сложения,
конечно можно определить оператор прямо внутри компилятора но мне кажется это не самая лучшая идея.
Все встроенные функции начинаются с "@" и работают как самые обыкновенные функции которые просто определяются внутри компилятора.

### @number
Ограничение типов для чисел, в него входят @u, @i, @f, @numlit, @floatlit

Сигнатура: `constexpr T::type -> bool`

### @numlit
Тип целых числовых литералов.

Сигнатура: `constexpr -> type(@number)`

### @floatlit
Тип числовых литералов с плавающей точкой.

Сигнатура: `constexpr -> type(@number)`

### @strlit
Тип строковых литералов.

Сигнатура: `constexpr -> type`

### @u
Тип бесзнаковых чисел, в аргументе необходимо указать битность.

Сигнатура: `constexpr bits::@numlit -> type(@number)`

### @i
Тип знаковых чисел, в аргументе необходимо указать битность.

Сигнатура: `constexpr bits::@numlit -> type(@number)`

### @f
Тип чисел c плавающей точкой, в аргументе необходимо указать битность.

Сигнатура: `constexpr bits::@numlit -> type(@number)`

### @add
Темплейт который возвращяет функцию для сложения 2 чисел.

Сигнатура: `constexpr T::type(@number) -> fn(a::T b::T -> T)`

### @sub
Темплейт который возвращяет функцию для вычитания 2 чисел.

Сигнатура: `constexpr T::type(@number) -> fn(a::T b::T -> T)`

### @mul
Темплейт который возвращяет функцию для умножения 2 чисел.

Сигнатура: `constexpr T::type(@number) -> fn(a::T b::T -> T)`

### @div
Темплейт который возвращяет функцию для деления 2 чисел.

Сигнатура: `constexpr T::type(@number) -> fn(a::T b::T -> T)`

### @ptr
Темплейт тип ссылки.

Сигнатура: `constexpr T::type -> type(@ptrable)`

### @ptrable
Ограничение которое проверяет является ли тип ссылкой.

Сигнатура: `constexpr T::type -> bool`

### @val
Темплейт функция для получения значения из ссылки.

Сигнатура: `constexpr T::type -> fn(x::@ptr(T) -> T)`

### @addr
Темплейт функция для получения ссылки из чего либо.

Сигнатура: `constexpr T::type -> fn(T -> @ptr(T))`

### @equalable
Ограничение которое проверяет можно ли сравнивать тип или нет.

Сигнатура: `constexpr T::type -> bool`

### @lessable
Ограничение которое проверяет можно ли проверять то что один эсемпляр типа меньше другово или нет.

Сигнатура: `constexpr T::type -> bool`

### @greatable
Ограничение которое проверяет можно ли проверять то что один эсемпляр типа больше другово или нет.

Сигнатура: `constexpr T::type -> bool`

### @equals
Темплейт функция которая сравнивает 2 значения.

Сигнатура: `constexpr T::type(@equalable) -> fn(a::T b::T -> bool)`

### @less
Темплейт функция которая проверяет что одно значение меньше другово.

Сигнатура: `constexpr T::type(@lessable) -> fn(a::T b::T -> bool)`

### @greater
Темплейт функция которая проверяет что одно значение больше другово.

Сигнатура: `constexpr T::type(@greatable) -> fn(a::T b::T -> bool)`

### @not
Функция логического отридцания (!x).

Сигнатура: `x::bool -> bool`

### @and
Функция логического и (a && b).

Сигнатура: `a::bool b::bool -> bool`

### @or
Функция логического или (a && b).

Сигнатура: `a::bool b::bool -> bool`

### @import
Импортирует модуль с указанным именем.

Сигнатура: `constexpr s::@strlit -> mod`

## Структуры
Структуры позволяют группировать данные в одном типе или создавать новый тип со старыми.

### Синтаксис
Что бы объявить тип структуры необходимо использовать синтаксис:
```
struct {
    <field_name::field_type...>,
}
```

### Темплейтирование структур
Структуры можно темплейтировать как и другие типы:
```
constexpr some_struct T::type -> type = struct {
    some_field::T,
};
```

### Конструкторы
Что бы создать эксемпляр структуры надо поставить круглые скобки после типа
и вписать туда значения всех полей структуры по порядку:
```
constexpr a -> type = struct { x::i32 };

instance -> a = a(10);
```

### Обращение к полям
Что бы обратится к полю структуры нужно использовать ".":
```
constexpr a -> type = struct { x::i32 };

instance -> a = a(10);
x_in_instance -> i32 = instance.x;
```

## Модули
Модули позволяют подключать код из других файлов в текущий.
Важнейшие концепции модулей это ключевое слово export,
тип mod, а так же встроенная функция @import. Стоит отметить
что модули работают только во время компиляции так как ключевое слово
@import а так же тип mod доступны только тогда.

Пример:
*файл main.ve*
```
constexpr std -> mod = @import("std");
constexpr lib -> mod = @import("lib");

impure main args::std.array(str) -> void = std.println("10 ** 2 = {}", lib.square(10));
```
*файл lib.ve*
```
export square x::i32 -> i32 = x * x;
```

### Ключевое слово include
Иногда надо подключать некоторые модули прямо к текущему модулю
без использования промежуточных переменных, в таком случаи можно
использовать ключевое слово include, оно имеет следующий синтаксис:
```
include <some_module>;
```

Пример:
*файл main.ve*
```
constexpr std -> mod = @import("std");

include @import("lib");

impure main args::std.array(str) -> void = std.println("10 ** 2 = {}", square(10));
```

## Конструкции
Конструкции это к примеру if'ы, циклы и тому подобное.

### Условные конструкции
Условные конструкции позволяют в зависимости от результата какого то выражения совершать какие либо действия

#### if
Условная конструкция if имеет такой синтаксис:
```
<flags...> if (<expr>) <expr> else <expr>
```

Для конструкции существуют следующие флаги:
- constexpr
- impure

Возможны только следующие комбинации:
| constexpr | impure | Описание |
| --- | --- | --- |
| Нет | Нет | if принимает значение времени выполнения и в любом случаи возвращяет результат с одним типом |
| Да | Нет | if принимает значение времени компиляции и в любом случаи возвращяет результат с одним типом времени компиляции |
| Нет | Да | if принимает значение времени выполнения и всегда возвращяет void, может не иметь else блока |
| Да | Да | if принимает значение времени компиляции и всегда возвращяет void, может не иметь else блока |

#### switch-case
Условная конструкция switch-case по факту тот же if но который автоматически настроен на сравнивание,
вот его синтаксис:
```
switch (<expr>) {
    case (<expr>),
}
```

### Циклы
В языке представлены 3 цикла:
- while
- do-while
- for-each

#### Цикл while
Цикл while принимает некоторое выражение которое возвращяет bool
и выполняет своё тело пока это выражение является истиной. Цикл всегда возвращяет void,
и является нечистым.
Вот его синтаксис:
```
while (<expr>) <expr>
```

#### Цикл do-while
Цикл do-while делает тоже самое что и while но если выражение изначально false
цикл while не выполняет своё тело тогда как do-while выполняет своё тело хотя бы 1 раз при любых
условиях. Он всегда возвращяет void и является нечистым. Вот его синтаксис:
```
do <expr> while (<expr>)
```

#### Цикл for-each
Цикл for-each пробегается по каждому объекту в итераторе и распаковывает его в переменную.
Всегда возвращяет void и является нечистым.
Вот его синтаксис:
```
for (let <var_name::var_type> : <iterable_name>) <expr>
```

### Список выражений
Список выражений нужен для последовательного выполнения нескольких выражений
внутри себя. Он возвращяет последнее выражение внутри себя. Всегда является нечистым.
Вот его синтаксис:
```
{ <expr...> }
```

## Переменные внутри нечистых функций
Если в нечистой функции объявить список выражений в нём можно
создавать переменные которые так же могут быть неконстантными.
Делается это с помощю ключегово слова let, что бы сделать переменную
мутабельной необходимо после него добавить mut.

Пример:
```
impure test x::i32 -> void = {
    let a::i32 = x * 2;
    let mut b::i32 = a;
    b = b * 2;
};
```

# Библиотека core
Библиотека core определяет базовые операторы, типы, итераторы, числа
и требуется для нормальной работы языка. Каждый модуль обязан инклюдить core
то есть в начале любого модуля автоматически должно стоять:
```
include @import("core");
```

Библиотека core состоит из следующих определений:
- Базовые числовые типы и операторы для них
- Некоторые дополнительные функции
- Типы и операторы для работы с указателями
- Типы для работы с языком си
- Библиотека для работы с итераторами

## Базовые числовые типы
Базовые числовые типы объявлены в корне библиотеки,
должны быть определены следующие типы:
- u8, u16, u32, u64
- i8, i16, i32, i64
- f32, f64
- bool

Их определения могут вылгядеть так:
```
export constexpr u8 -> type = @u(8);
export constexpr u16 -> type = @u(16);
export constexpr u32 -> type = @u(32);
export constexpr u64 -> type = @u(64);

export constexpr i8 -> type = @i(8);
export constexpr i16 -> type = @i(16);
export constexpr i32 -> type = @i(32);
export constexpr i64 -> type = @i(64);

export constexpr f32 -> type = @f(32);
export constexpr f64 -> type = @f(64);

export constexpr bool -> type = @u(1);
```

Так же для типов u* i* f* должны быть определены следующие операторы:
- `+`
- `-`
- `*`
- `/`
- `==`
- `<`
- `>`
- `>=`
- `<=`

Вот как могут выглядеть их определения:
```
export operator + a::u8 b::u8 -> u8 = @add(u8);
export operator + a::u16 b::u16 -> u16 = @add(u16);
export operator + a::u32 b::u32 -> u32 = @add(u32);
export operator + a::u64 b::u64 -> u64 = @add(u64);

export operator + a::i8 b::i8 -> i8 = @add(i8);
export operator + a::i16 b::i16 -> i16 = @add(i16);
export operator + a::i32 b::i32 -> i32 = @add(i32);
export operator + a::i64 b::i64 -> i64 = @add(i64);

export operator - a::u8 b::u8 -> u8 = @sub(u8);
export operator - a::u16 b::u16 -> u16 = @sub(u16);
export operator - a::u32 b::u32 -> u32 = @sub(u32);
export operator - a::u64 b::u64 -> u64 = @sub(u64);

export operator - a::i8 b::i8 -> i8 = @sub(i8);
export operator - a::i16 b::i16 -> i16 = @sub(i16);
export operator - a::i32 b::i32 -> i32 = @sub(i32);
export operator - a::i64 b::i64 -> i64 = @sub(i64);

export operator * a::u8 b::u8 -> u8 = @mul(u8);
export operator * a::u16 b::u16 -> u16 = @mul(u16);
export operator * a::u32 b::u32 -> u32 = @mul(u32);
export operator * a::u64 b::u64 -> u64 = @mul(u64);

export operator * a::i8 b::i8 -> i8 = @mul(i8);
export operator * a::i16 b::i16 -> i16 = @mul(i16);
export operator * a::i32 b::i32 -> i32 = @mul(i32);
export operator * a::i64 b::i64 -> i64 = @mul(i64);

export operator / a::u8 b::u8 -> u8 = @div(u8);
export operator / a::u16 b::u16 -> u16 = @div(u16);
export operator / a::u32 b::u32 -> u32 = @div(u32);
export operator / a::u64 b::u64 -> u64 = @div(u64);

export operator / a::i8 b::i8 -> i8 = @div(i8);
export operator / a::i16 b::i16 -> i16 = @div(i16);
export operator / a::i32 b::i32 -> i32 = @div(i32);
export operator / a::i64 b::i64 -> i64 = @div(i64);

export operator == a::u8 b::u8 -> bool = @equals(u8);
export operator == a::u16 b::u16 -> bool = @equals(u16);
export operator == a::u32 b::u32 -> bool = @equals(u32);
export operator == a::u64 b::u64 -> bool = @equals(u64);

export operator == a::i8 b::i8 -> bool = @equals(i8);
export operator == a::i16 b::i16 -> bool = @equals(i16);
export operator == a::i32 b::i32 -> bool = @equals(i32);
export operator == a::i64 b::i64 -> bool = @equals(i64);

export operator != a::u8 b::u8 -> bool = !@equals(u8)(a, b);
export operator != a::u16 b::u16 -> bool = !@equals(u16)(a, b);
export operator != a::u32 b::u32 -> bool = !@equals(u32)(a, b);
export operator != a::u64 b::u64 -> bool = !@equals(u64)(a, b);

export operator != a::i8 b::i8 -> bool = !@equals(i8)(a, b);
export operator != a::i16 b::i16 -> bool = !@equals(i16)(a, b);
export operator != a::i32 b::i32 -> bool = !@equals(i32)(a, b);
export operator != a::i64 b::i64 -> bool = !@equals(i64)(a, b);

export operator < a::u8 b::u8 -> bool = @less(u8);
export operator < a::u16 b::u16 -> bool = @less(u16);
export operator < a::u32 b::u32 -> bool = @less(u32);
export operator < a::u64 b::u64 -> bool = @less(u64);

export operator < a::i8 b::i8 -> bool = @less(i8);
export operator < a::i16 b::i16 -> bool = @less(i16);
export operator < a::i32 b::i32 -> bool = @less(i32);
export operator < a::i64 b::i64 -> bool = @less(i64);

export operator <= a::u8 b::u8 -> bool = @less(u8)(a, b) || a == b;
export operator <= a::u16 b::u16 -> bool = @less(u16)(a, b) || a == b;
export operator <= a::u32 b::u32 -> bool = @less(u32)(a, b) || a == b;
export operator <= a::u64 b::u64 -> bool = @less(u64)(a, b) || a == b;

export operator <= a::i8 b::i8 -> bool = @less(i8)(a, b) || a == b;
export operator <= a::i16 b::i16 -> bool = @less(i16)(a, b) || a == b;
export operator <= a::i32 b::i32 -> bool = @less(i32)(a, b) || a == b;
export operator <= a::i64 b::i64 -> bool = @less(i64)(a, b) || a == b;

export operator >= a::u8 b::u8 -> bool = @greater(u8)(a, b) || a == b;
export operator >= a::u16 b::u16 -> bool = @greater(u16)(a, b) || a == b;
export operator >= a::u32 b::u32 -> bool = @greater(u32)(a, b) || a == b;
export operator >= a::u64 b::u64 -> bool = @greater(u64)(a, b) || a == b;

export operator >= a::i8 b::i8 -> bool = @greater(i8)(a, b) || a == b;
export operator >= a::i16 b::i16 -> bool = @greater(i16)(a, b) || a == b;
export operator >= a::i32 b::i32 -> bool = @greater(i32)(a, b) || a == b;
export operator >= a::i64 b::i64 -> bool = @greater(i64)(a, b) || a == b;
```

Для типа bool необходимо определить следующие операторы:
- `!`
- `&&`
- `||`

Вот как могут выглядеть их определения:
```
export loperator ! a::bool -> bool = @not;
export operator && a::bool b::bool -> bool = @and;
export operator || a::bool b::bool -> bool = @or;
```

## Некоторые дополнительные функции
Библиотека также должна дополнительно определить:
- Темплейт ограничение same_as
- Оператор сравнения для типа типов

### Темплейт ограничение same_as
Это ограничение принимает на вход темплейта тип и возвращяет ограничение которое
сравнивает равен ли тип который нужно ограничить типу который был передан в same_as.
Это можно определить как:
```
export constexpr same_as T::type -> constexpr fn(Y::type -> bool) =
    (constexpr Y::type -> bool | T == Y);
```

### Оператор сравнения для типа типов
Просто определение оператора `==` для типа типов:
```
export constexpr operator == a::type b::type -> bool = @equals(type);
```

## Типы и определения для указателей
В библиотеке core должны быть объявлен оператор который позволит быстро создавать
типы ссылок из обычных типов. Он должен иметь примерно следующее определение:
```
export constexpr roperator * T::type -> type(@ptrable) = @ptr;
```

## Типы для языка си
Типы для языка си должны экспортироватся через модуль c_type,
требуются следующие типы:
- c_type.uchar
- c_type.schar
- c_type.ushort
- c_type.sshort
- c_type.uint
- c_type.sint
- c_type.ulong
- c_type.slong
- c_type.ulonglong
- c_type.slonglong
- c_type.float
- c_type.double
- c_type.void_ptr

Вот как могут выглядить их определения (для архитектуры x86-64):
```
export constexpr uchar -> type = u8;
export constexpr schar -> type = i8;

export constexpr ushort -> type = u16;
export constexpr sshort -> type = i16;

export constexpr uint -> type = u32;
export constexpr sint -> type = i32;

export constexpr ulong -> type = u32;
export constexpr slong -> type = i32;

export constexpr ulonglong -> type = u64;
export constexpr slonglong -> type = i64;

export constexpr float -> type = f32;
export constexpr double -> type = f64;

export constexpr void_ptr -> type = void*;
```

## Итераторы
Библиотека итераторов содержится в экспортированном модуле iter.

Итерируемый тип это такой тип, для которого определены 2 перегрузки функци:
функция begin и функция end, они в свою очередь должны вернуть объект который поддерживает
оператор `==`, `++` и оператор `*`.
- Оператор `==` сравнивает 2 итератора
- Оператор `++` заставляет итератор переместится к следующему элементу
- Оператор `*` получает текущий объект на который указывает итератор

Модуль iter должен определить 2 ограничения:
- iterable - ограничение которое требует наличия методов begin и end
- iterator - ограничение которое требует наличия операторов `==`, `++`, `*`

### Ограничение iterable
Ограничение может быть объявлено следующим образом:
```
export constexpr iterable T::type -> bool = check (T x) {
    { begin(x) } -> (iter.iterator),
    { end(x) } -> (iter.iterator),
};
```

### Ограничение iterator
Ограничение может быть объявлено следующим образом:
```
export constexpr iterator T::type -> bool = check (T x) {
    { x == x } -> (same_as(bool)),
    { x++ } -> (same_as(T)),
    { *x } -> (),
};
```

Пример собственного итератора:
```
constexpr iota -> type(iter.iterable) = struct {
    start::i32,
    end::i32,
};

constexpr iota_iter -> type(iter.iterator) = struct {
    ptr::i32,
};

operator == a::iota_iter b::iota_iter -> bool = a.ptr == b.ptr;
roperator ++ x::iota_iter -> iota_iter = iota_iter(x.ptr + 1);
loperator * x::iota_iter -> i32 = x.ptr;

begin x::iota -> iota_iter = iota_iter(x.start);
end x::iota -> iota_iter = iota_iter(x.end);

...

for (let i::i32 : iota(0, 10))
    std.println("i = {}", i);
```
